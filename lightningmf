#! /usr/bin/env python
#    Lightning MAME Frontend
#    Copyright (C) 2012 Nicolas Vanhoren
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

from PySide import QtGui
from PySide import QtUiTools
import sys
import tempfile
import subprocess
from lightningmf_pk.KeyFilter import KeyFilter
from lightningmf_pk.MyModel import *
from lightningmf_pk.DownloadingWindow import DownloadingWindow
import json
import shlex
import random
import requests
import shutil
import errno

SCRIPT_ROOT = os.path.dirname(os.path.realpath(__file__)) + "/lightningmf_pk/"


# gui
class FrontendApplication:
    def launch(self):
        self.configuration = {
            "mameExecutable": "",
            "commandLineArguments": "",
            "snapsFolder": "",
            "romsFolder": "",
        }
        self.loadConfigFile()

        self.app = QtGui.QApplication(sys.argv)

        key_filter = KeyFilter()
        self.app.installEventFilter(key_filter)

        loader = QtUiTools.QUiLoader()
        loader.setWorkingDirectory(QtCore.QDir(SCRIPT_ROOT))
        file = QtCore.QFile(os.path.join(SCRIPT_ROOT, "view.ui"))
        try:
            file.open(QtCore.QFile.ReadOnly)
            self.win = loader.load(file)
        finally:
            file.close()

        self.win.move(QtGui.QDesktopWidget().availableGeometry().center() - self.win.geometry().center())
        self.settings = QtCore.QSettings("qsdoiuhvap", "xpoihybao")
        self.win.restoreGeometry(self.settings.value("geometry"))
        self.win.show()

        self.model = MyModel()
        self.win.itemsView.setModel(self.model)
        self.win.itemsView.horizontalHeader().setResizeMode(0, QtGui.QHeaderView.Stretch)
        self.win.itemsView.doubleClicked.connect(self.launchGame)
        key_filter.returnPressed.connect(self.launchGame)
        key_filter.escapePressed.connect(self.app.quit)
        x = self.win.itemsView.selectionModel()
        x.selectionChanged.connect(self.selectionChanged)

        def set_number():
            num = self.model.rowCount()
            self.win.romsNumberLabel.setText("%d roms" % num)

        self.model.modelReset.connect(set_number)
        set_number()

        self.win.actionRoms.triggered.connect(self.loadRoms)

        self.win.actionMame.triggered.connect(self.configure)

        self.win.searchInput.textEdited.connect(self.searchChanged)

        self.win.loadButton.clicked.connect(self.loadRoms)
        self.win.settingsButton.clicked.connect(self.configure)
        self.win.snapsButton.clicked.connect(self.downloadSnaps)

        def starting():
            if self.configuration["mameExecutable"] == "":
                ret = QtGui.QMessageBox.question(self.win, "Configuration Missing",
                                                 "Lightning MAME Frontend is not configured, do you " \
                                                 + "want to configure it now?",
                                                 buttons=QtGui.QMessageBox.Yes | QtGui.QMessageBox.No,
                                                 defaultButton=QtGui.QMessageBox.Yes)
                if ret == QtGui.QMessageBox.Yes:
                    try:
                        subprocess.check_call(['mame', "-help"])
                        self.configuration["mameExecutable"] = "mame"
                        self.configuration["romsFolder"] = os.path.expanduser("~/.mame/roms")
                        self.configuration["snapsFolder"] = os.path.expanduser("~/.mame/snap")
                    except:
                        pass
                    self.configure()

        QtCore.QTimer.singleShot(0, starting)

        self.trueLoadRoms()

        self.settings.setValue("geometry", self.win.saveGeometry())

        self.app.exec_()

    def parse_elements(self, filename):
        session.begin()
        try:
            import xml.etree.ElementTree as etree
            with open(filename) as tmpfile:
                doc = etree.iterparse(tmpfile, events=("start", "end"))
                doc = iter(doc)
                event, root = doc.next()
                num = 0
                for event, elem in doc:
                    if event == "end" and elem.tag == "game":
                        name = elem.get("name")
                        if not os.path.exists(os.path.join(self.configuration["romsFolder"], name + ".zip")):
                            root.clear()
                            continue
                        desc = elem.findtext("description") or ""
                        year = elem.findtext("year") or ""
                        manu = elem.findtext("manufacturer") or ""
                        clone = elem.get("cloneof") or None
                        status = ""
                        driver = elem.find("driver")
                        if driver is not None:
                            status = driver.get("status") or ""
                        game = Game(name=name, description=desc, year=year, manufacturer=manu, status=status,
                                    cloneof=clone)
                        session.add(game)
                        if num >= 200:
                            session.commit()
                            num = 0
                        root.clear()
            session.commit()
        except:
            session.rollback()
            raise

    def loadRoms(self):
        try:
            downWindows = DownloadingWindow('loading roms...')
            downWindows.show()
            QtCore.QTimer.singleShot(0, self.trueLoadRoms(downWin=downWindows))
            downWindows.close()
        except:
            pass

    def update_db(self):
        rompath = os.path.join(self.configuration["romsFolder"])

        # remove from db roms deleted from romsFolder
        added_roms = []
        dblist = []
        result = session.execute(session.query(Game.name))
        for line in result:
            dblist.append(line[0])

        for root, dirs, files in os.walk(rompath):
            for rom in files:
                rom = os.path.splitext(rom)[0]
                added_roms.append(rom)
        toremovelist = dblist[:]
        for rom in added_roms:
            if rom in dblist:
                toremovelist.remove(rom)
        downWindows = DownloadingWindow('Romlist update...')
        count = 0
        if toremovelist:
            downWindows.show()
            percent = float(100 / len(toremovelist))
        for rom in toremovelist:
            downWindows.setProgress(float(percent * count))
            count += 1
            session.query(Game).filter(Game.name == rom).delete(synchronize_session=False)
        self.model.modelReset.emit()

    def trueLoadRoms(self, *args, **kwargs):
        filename = tempfile.mktemp()
        rompath = os.path.join(self.configuration["romsFolder"])
        self.update_db()
        # rom on db
        finaldblist = []
        result = session.execute(session.query(Game.name))
        for line in result:
            finaldblist.append(line[0])
        if os.path.exists(rompath):
            romCount = len([name for name in os.listdir(rompath) if os.path.isfile(os.path.join(rompath, name))])

            count = 1
            # print "Rom count: {} dblist: {}".format(romCount, len(finaldblist))
            romCount -= len(finaldblist)
            # print "diff: {}".format(romCount)
            for root, dirs, files in os.walk(rompath):
                for rom in files:
                    rom = os.path.splitext(rom)[0]
                    with open(filename, "w") as tmpfile:
                        try:
                            if rom not in finaldblist:
                                if kwargs:
                                    kwargs['downWin'].setProgress(float((100 / romCount) * count))
                                    count += 1
                                subprocess.check_call([self.configuration["mameExecutable"], "-listxml", rom],
                                                      stdout=tmpfile, stderr=subprocess.PIPE)
                                self.parse_elements(filename)
                                self.model.modelReset.emit()
                        except Exception:
                            continue
            self.win.statusBar().showMessage("Rom update succeeded", 2000)

    def searchChanged(self, text):
        self.model.searchString = text
        self.model.modelReset.emit()

    def _getSelected(self):
        selected = self.win.itemsView.selectedIndexes()
        if len(selected) == 0:
            return
        selected = selected[0].row()
        return self.model._getRow(selected)

    def launchGame(self):
        game = self._getSelected()
        if game:
            try:
                subprocess.check_call([self.configuration["mameExecutable"], "-rompath", self.configuration["romsFolder"],  game["game_name"]] \
                                      + shlex.split(self.configuration["commandLineArguments"]))
            except Exception as e:
                QtGui.QMessageBox.critical(self.win, "Error", "An error occured while launching this game")

    def selectionChanged(self, *args):
        game = self._getSelected()
        self.setGameImage(game)

    def downloadSnaps(self):
        snapspath = os.path.join(self.configuration["snapsFolder"])
        dblist = []
        result = session.execute(session.query(Game.name))
        for line in result:
            dblist.append(line[0])

        downWindows = DownloadingWindow('Downloading snapshots from mamedb.com')
        count = 0
        if dblist:
            downWindows.show()
            percent = float(100 / len(dblist))
            if not os.path.exists(snapspath):
                os.makedirs(snapspath)
            else:
                for line in dblist:
                    try:
                        downWindows.setProgress(float(percent * count))
                        count += 1
                        filename = snapspath + "/"+line+"/"+line+".png"
                        if not os.path.exists(os.path.dirname(filename)):
                            try:
                                os.makedirs(os.path.dirname(filename))
                            except OSError as exc:
                                print "OS error"
                                # Guard against race condition
                                if exc.errno != errno.EEXIST:
                                    raise
                            url = "http://www.mamedb.com/snap/" + line + ".png"
                            r = requests.get(url, stream=True)
                            if r.status_code == 200:
                                with open(filename, 'wb') as f:
                                    r.raw.decode_content = True
                                    shutil.copyfileobj(r.raw, f)
                    except:
                        continue

    def setGameImage(self, game):
        path = os.path.join(self.configuration["snapsFolder"], game["game_name"])
        if not os.path.exists(path):
            clone = game["game_cloneof"]
            if clone is not None:
                result = session.execute(session.query(Game).filter(Game.name == clone))
                result = [dict(x) for x in result]
                parent = result[0] if len(result) >= 1 else None
                if parent is not None:
                    return self.setGameImage(parent)
        else:
            try:
                images_list = []
                for root, dirs, files in os.walk(path):
                    for fil in files:
                        if fil.endswith(".png"):
                            images_list.append(fil)

                image = random.choice(images_list)
                img = QtGui.QImage()
                img.load(path + "/" + image)
                size = QtCore.QSize(self.win.imageLabel.width(), self.win.imageLabel.height())
                img = img.scaled(size, QtCore.Qt.KeepAspectRatio)
                pix = QtGui.QPixmap.fromImage(img)
                self.win.imageLabel.setPixmap(pix)
            except Exception:
                pass

    def configure(self):
        loader = QtUiTools.QUiLoader()
        file = QtCore.QFile(os.path.join(SCRIPT_ROOT, "config.ui"))
        try:
            file.open(QtCore.QFile.ReadOnly)
            self.confDial = loader.load(file)
        finally:
            file.close()

        self.confDial.mameExecInput.setText(self.configuration["mameExecutable"])
        self.confDial.cmdInput.setText(self.configuration["commandLineArguments"])
        self.confDial.snapsInput.setText(self.configuration["snapsFolder"])
        self.confDial.romsInput.setText(self.configuration["romsFolder"])

        def browse():
            name = QtGui.QFileDialog.getOpenFileName(self.confDial, "Choose MAME Executable")
            if len(name[0]) > 0:
                self.confDial.mameExecInput.setText(name[0])

        self.confDial.browseButton.clicked.connect(browse)

        def snapsBrowse():
            name = QtGui.QFileDialog.getExistingDirectory(self.confDial, "Choose Snapshots Folder")
            if len(name) > 0:
                self.confDial.snapsInput.setText(name)

        self.confDial.snapsButton.clicked.connect(snapsBrowse)

        def romsBrowse():
            name = QtGui.QFileDialog.getExistingDirectory(self.confDial, "Choose Roms Folder")
            if len(name) > 0:
                self.confDial.romsInput.setText(name)

        self.confDial.romsButton.clicked.connect(romsBrowse)

        def save():
            params = {
                "mameExecutable": self.confDial.mameExecInput.text(),
                "commandLineArguments": self.confDial.cmdInput.text(),
                "snapsFolder": self.confDial.snapsInput.text(),
                "romsFolder": self.confDial.romsInput.text(),
            }
            dump = json.dumps(params)
            with open(confFile, "w") as file:
                file.write(dump)
            self.loadConfigFile()
            if self.model.rowCount() == 0:
                ret = QtGui.QMessageBox.question(self.confDial, "Roms Loading", "Do you want to load the roms now?",
                                                 buttons=QtGui.QMessageBox.Yes | QtGui.QMessageBox.No,
                                                 defaultButton=QtGui.QMessageBox.Yes)
                if ret == QtGui.QMessageBox.Yes:
                    QtCore.QTimer.singleShot(0, self.loadRoms)

        self.confDial.buttonBox.accepted.connect(save)

        self.confDial.show()

    def loadConfigFile(self):
        if not os.path.exists(confFile):
            return
        with open(confFile) as file:
            tmp = file.read()
        self.configuration = json.loads(tmp)


def main():
    if len(sys.argv) >= 2 and sys.argv[1] == "-flush":
        drop_db()
    init_db()
    FrontendApplication().launch()
    engine.dispose()
    os._exit(0)


if __name__ == '__main__':
    main()
